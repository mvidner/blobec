#! /usr/bin/env ruby

require "pp"
#require "uri"
require "rubygems"
require "rake"
require "fileutils"

require 'optparse'

$remote = "origin"

opts = OptionParser.new
opts.on("-r", "--remote NAME", String) {|n| $remote = n }
command, filename = opts.parse(*ARGV)

def url_for(filename)
  File.new(filename + ".blburl." + $remote).readline.chomp
end


#url_s = ARGV[0]
#url = URI.parse url_s
#filename = ARGV[1] || url.path[%r{.*/(.*)},1]

def sys(array)
  sh *array
end

module Blobec
  class XTransport
    attr_accessor :filename, :url

    def initialize(filename, url)
      self.filename = filename
      self.url = url
    end

    def locked_url
      url + ".locked"
    end

  end

  module Transport
    module Ftp
      extend self

      # url -> filename
      def get(url, filename)
        curl %w{--remote-time --output} + [filename, url.to_s]
      end

      # filename -> url
      def put(filename, url)
        curl ["--upload-file", filename, url.to_s]
      end

      def lock(url)
        locked_url = url + ".locked"
        dir, slash, base = url.rpartition "/"
        mv(dir + "/", base, base + ".locked") && locked_url || nil
      end

      def unlock(url)
        dir, slash, base = url.rpartition "/"
        mv(dir + "/", base + ".locked", base)
      end

      private

#      CURL_FLAGS = %w{--verbose --netrc-optional --ftp-ssl --insecure}
      CURL_FLAGS = %w{--netrc-optional --ftp-ssl --insecure}

      def curl(array)
        # insecure sucks. should --cacert help?
        sys %w{curl} + CURL_FLAGS + array
      end

      def mv(path, from, to)
        args = ["curl", CURL_FLAGS, "-f", "-Q", "+RNFR #{from}", "-Q", "+RNTO #{to}", "--range", "0-0", "-o", "/dev/null", path + to].flatten
        pp args
        system(*args)
        $?.success?
      end

      # these are obsolete?
      def upload_ts(url, filename)
        upload url, filename
        tfn = filename + ".timestamp"
        timestamp(url, tfn)
        theirs_ts = mtime(tfn)
        File.utime(0, theirs_ts, filename)
        rm tfn
      end

      def timestamp(url, filename)
        curl %w{--remote-time --range 0-0 --output} + [filename, url.to_s]
      end

      def mtime(filename)
        File.new(filename).mtime
      end
    end # module Ftp

    module File
      extend self

      # url -> filename
      def get(url, filename)
        FileUtils.cp remote_filename(url), filename
      end

      # filename -> url
      def put(filename, url)
        p self
        FileUtils.cp filename, remote_filename(url)
      end

      # TODO ensure that create will not kill an existing blob
      def create
        FileUtils.touch remote_filename
      end

      private

      def remote_filename(url)
        url.sub %r{^file://}, ""
      end
    end # module File
  end # module Transport

  module Wrap
    extend self

    def wrap(git_dir, pack_filename)
      local = "file://" + File.expand_path(git_dir)
      mktemp("-d #{git_dir}.bare.git.XXXXXX") do |git|
        sys %w{git clone --bare} + [local, git]
        mktemp(git_dir + ".tar.XXXXXX") do |tar|
          sys %w{tar cvf} + [tar, "-C", git, "."]
          sys %w{gpg --encrypt --default-recipient-self --output} + [pack_filename, tar]
        end
      end
    end  

    # empty git_dir needs to exist already
    def unwrap(pack_filename, git_dir)
      git = nil
      mktemp(pack_filename + ".tar.XXXXXX") do |tar|
        # interactive (yes=overwrite existing file)
        sys %w{gpg --decrypt --yes --output} + [tar, pack_filename]
        sys %w{tar -f} + [tar, "-C", git_dir, "-xv"]
      end
      git
    end
  end

  module Vcs
    module Git
      extend self

      # compare two blobs
      # newer, equal, DIVERGED=nil
      def compare(a, b)
        atob = dry_push a, b
        btoa = dry_push b, a
        both = atob + btoa
        if both < -1 or both > 1
          nil
        else
          both
        end
      end

      def dry_push(dir_a, dir_b)
        out = `cd #{dir_a}; git push --dry-run --verbose --porcelain #{dir_b}`
        if $?.success # a >= b
          results = out.grep /^[ =!]/ # space:success, =:unchanged, !:failed
          if results.all? {|r| r =~ /^=/ }
            0                   # equal
          else
            1                   # at least 1 fast forward: a > b
          end
        else
          -1                    # push failed: a < b or something else
        end
      end
    end
  end
end

require "fileutils"
include FileUtils

def merge(theirs, mine, result)
  puts "MERGE", theirs, mine, result
  if identical? theirs, mine
    mv theirs, result
    rm mine
    puts "SAME CONTENT"
  end
end

def update(filename)
  url = url_for(filename)
  tfn = filename + ".timestamp"
  timestamp(url, tfn)
  mine_ts = mtime(filename)
  theirs_ts = mtime(tfn)
  if theirs_ts == mine_ts
    puts "SAME TIMESTAMP"
    return
  end
  theirs_fn = filename + ".theirs"
  download(url, theirs_fn)
  mine_fn = filename + ".mine"
  mv filename, mine_fn
  merge theirs_fn, mine_fn, filename
end

def mktemp(template)
  t = `mktemp #{template}`.chomp
  fail unless $?.success?
  if block_given?
    begin
      yield t
    ensure
      rm_r t
    end
  else
    t
  end
end

def git_push(source_git, target_git)
  puts "DRY RUN"
  push = "git push --dry-run --verbose --porcelain"
  system "cd #{source_git}; #{push} #{target_git} || #{push} #{target_git}/*.git"
  $?.success?
end

def wrapped_git_push(git_local, gtg_target)
  status = nil
  mktemp("-d #{gtg_target}.bare.git.XXXXXX") do |git_target|
    Blobec::Wrap.unwrap(gtg_target, git_target)
    status = git_push(git_local, git_target)
    if status
      Blobec::Wrap.wrap(git_target, gtg_target)
    end
  end
  status
end

def push(git_dir, url, transport)
  locked_url = transport.lock(url)
  unless locked_url.nil?
    begin
      mktemp locked_url[%r{.*/(.*)},1] + ".proxy.XXXXXX" do |proxy|
        transport.get(locked_url, proxy)
        if wrapped_git_push(git_dir, proxy)
          transport.put(proxy, locked_url)
        end
      end
    ensure
      transport.unlock(url)
    end
  end
end

def fetch(url, filename, transport)
  transport.get(url, temp_filename)
  copy_git = Blobec::Wrap.unwrap(gtg_target)
  begin
    system "cd #{source_git}; git push --dry-run --verbose --porcelain #{target_git}"
  ensure
    # rm_rf copy_git
  end
end

url = url_for filename
# -> factory method in Blobec
transport = Blobec::Transport.const_get(url.sub(/:.*/, "").capitalize)

case command
# low level transport commands
when "get":
    transport.get(url, filename)
when "put":
    transport.put(filename, url)
when "lock"
  locked_url = transport.lock(url)
  puts locked_url || "FAILED"
when "unlock"
  transport.unlock(url)
when "up", "update":
    update(filename)
when "ci", "checkin":
when "st", "status":
    system "ls -l #{filename}*"
when "upload":
    upload(url, filename)
when "push":
    push(filename, url, transport)
when "fetch":
    fetch url, filename
when "create":
    transport.create
else
    $stderr.puts "Unknown command '#{command}'"
end
