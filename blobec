#! /usr/bin/env ruby

require "pp"
#require "uri"
require "rubygems"
require "rake"
#require "net/ftp-netrc"
require "fileutils"

require 'optparse'

$remote = "origin"

opts = OptionParser.new
opts.on("-r", "--remote NAME", String) {|n| $remote = n }
command, filename = opts.parse(*ARGV)

def url_for(filename)
  File.new(filename + ".blburl." + $remote).readline.chomp
end


#url_s = ARGV[0]
#url = URI.parse url_s
#filename = ARGV[1] || url.path[%r{.*/(.*)},1]

module Blobec
  class Transport
    attr_accessor :filename, :url

    def initialize(filename, url)
      self.filename = filename
      self.url = url
    end

    def locked_url
      url + ".locked"
    end

    def update
      lock
      get
      yield
      put
      unlock
    end
  end

  class Ftp < Transport
  end

  class File < Transport
    def remote_filename(u = url)
      u.sub %r{^file://}, ""
    end

    def get
      FileUtils.cp remote_filename, filename
    end

    def put
#      FileUtils.cp filename, ...
    end

    # TODO ensure that create will not kill an existing blob
    def create
      FileUtils.touch remote_filename
    end
  end
end



def sys(array)
  sh *array
end

def curl(array)
  # insecure sucks. should --cacert help?
  sys %w{curl --verbose --netrc-optional --ftp-ssl --insecure} + array
end

def upload(url, filename)
  curl ["--upload-file", filename, url.to_s]
end

def upload_ts(url, filename)
  upload url, filename
  tfn = filename + ".timestamp"
  timestamp(url, tfn)
  theirs_ts = mtime(tfn)
  File.utime(0, theirs_ts, filename)
  rm tfn
end

def download(url, filename)
  curl %w{--remote-time --output} + [filename, url.to_s]
end

def timestamp(url, filename)
  curl %w{--remote-time --range 0-0 --output} + [filename, url.to_s]
end

def mtime(filename)
  File.new(filename).mtime
end

require "fileutils"
include FileUtils

def merge(theirs, mine, result)
  puts "MERGE", theirs, mine, result
  if identical? theirs, mine
    mv theirs, result
    rm mine
    puts "SAME CONTENT"
  end
end

def update(filename)
  url = url_for(filename)
  tfn = filename + ".timestamp"
  timestamp(url, tfn)
  mine_ts = mtime(filename)
  theirs_ts = mtime(tfn)
  if theirs_ts == mine_ts
    puts "SAME TIMESTAMP"
    return
  end
  theirs_fn = filename + ".theirs"
  download(url, theirs_fn)
  mine_fn = filename + ".mine"
  mv filename, mine_fn
  merge theirs_fn, mine_fn, filename
end

def pack(filename)
  local = "file://" + File.expand_path(filename)
  git = filename + ".git"
  sys %w{git clone --bare} + [local, git]
  tar = git + ".tar"
  sys %w{tar cvf} + [tar, git]
  gtg = filename + ".gtg"
  sys %w{gpg --encrypt --default-recipient-self --output} + [gtg, tar]
end

def push(filename)
  pack filename
  gtg = filename + ".gtg"
  upload_ts url_for(gtg), gtg
  rm tar
  rm_r git
end

def unpack(filename)
  git = filename + ".git"
  tar = git + ".tar"
  gtg = filename + ".gtg"
  sys %w{gpg --decrypt --output} + [tar, gtg]
  # dumb
  sys %w{tar xvf} + [tar]
end

def fetch(filename)
  update(filename + ".gtg")
  unpack filename
end

url = url_for filename
# -> factory method in Blobec
klass = Blobec.const_get(url.sub(/:.*/, "").capitalize)
transfer = klass.new(filename, url)

case command
when "up", "update":
    update(filename)
when "ci", "checkin":
when "st", "status":
    system "ls -l #{filename}*"
when "upload":
    upload(url, filename)
when "push":
    push filename
when "fetch":
    fetch filename
when "create":
    transfer.create
end
